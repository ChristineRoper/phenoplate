Processes the RLC part of the Fluorcam data with PI curves to extract Pmax, alpha, ek

```{r, setup, include=FALSE}
knitr::opts_knit$set(root.dir = "~/Documents/PhD/Chapter 3/Data/Phenoplate data/R analysis")

input <- "2. Rapid Light Curves/fluorcam_RLC_data.csv"
output <- "2. Rapid Light Curves/rlc_qy_metrics_webb.csv"
plots <- "2. Rapid Light Curves/QY/plots/"
```


```{r}
rlc_data <- read.csv(input, header = TRUE, colClasses = c(
    "character",
    "factor", "factor", "factor", "factor", "factor", "factor", "factor",
    "numeric", "numeric", "numeric", "numeric"
))
```

```{r}
library(ggplot2)
source("utils/christineTheme.r")
```

```{R}
library(minpack.lm) # for nlsLM
library(broom) # for augment
source("utils/nls_outlier_removal.r")


Webb_PI <- function(I, Pmax, alpha) {
    Ek <- Pmax / alpha
    return(
        Pmax * (1 - exp(-I / Ek))
    )
}

Webb_QY_PI <- function(QY_max, Ek, I) { # modified for QY as per Emma's Excel sheet
    Pmax <- QY_max * Ek
    alpha <- Pmax / Ek
    return(Webb_PI(I, Pmax, alpha) / I)
}

Eilers_PI <- function(Pmax, Iopt, a, I) {
    pi <- (Pmax * I) / ((Pmax / (a * Iopt^2)) * I^2 + ((1 - (2 * Pmax) / (a * Iopt)) * I) + (Pmax / a))
    return(pi)
}

Eilers_QY_PI <- function(QY_max, IoptExtra, Ek, I) {
    Iopt <- Ek + IoptExtra
    Pmax <- QY_max * Ek
    alpha <- Pmax / Ek
    return(Eilers_PI(Pmax, Iopt, alpha, I) / I)
}


sampleIDs <- c(
    "LI F20",
    "LI F1",
    "LI F2",
    "LI F8",
    "LI S1",
    "LI S3",
    "MO S1",
    "MO S9",
    "RB S1",
    "RB S9",
    "BH 1",
    "BH 6",
    "TB 2"
)
sampleIDs <- levels(as.factor(rlc_data$SampleID)) # all samples

output_data <- NULL

printOnTop <- function(...values) {
    cat("\33[2K\r", ...values)
}


cat("\n")
for (sample in sampleIDs) {
    printOnTop(sample)

    plot <- ggplot() + christineTheme
    fit_curves <- NULL

    sampleData <- filter(rlc_data, SampleID == sample)

    # Ensure no QY is negative
    sampleData$QY <- pmax(sampleData$QY, 0)

    for (area in 1:6) {
        # cat(" area ", area)
        areaData <- filter(sampleData, Area == area)

        simpleMax <- max(areaData$QY)

        # Fit
        ###########

        # First par is never an outlier
        handle_outliers <- function(outliers) filter(outliers, PAR > 100)

        fit_data <- function(data) {
            tryCatch(
                {
                    nlsLM(
                        QY ~ Webb_QY_PI(QY_max, Ek, PAR),
                        data = data,
                        start = list(QY_max = simpleMax, Ek = 500),
                        lower = c(0, 0),
                        upper = c(0.8, 1700),
                        control = nls.lm.control(maxiter = 500),
                        # trace=TRUE
                    )
                },
                error = function(e) {
                    cat("error in ", sample, " area ", area, " fit 1\n")
                    stop(e)
                }
            )
        }

        fit <- nls_outlier_removal(
            areaData,
            fit_data = fit_data,
            handle_outliers = handle_outliers
        )

        outliers <- fit$outliers
        fit <- fit$fit

        # plot them to see what's being removed
        if (length(outliers)) {
            plot <- plot +
                geom_point(data = outliers, aes(x = PAR, y = QY), colour = "red", pch = 1, size = 3)
        }

        Ek <- coef(fit)[["Ek"]]
        # IoptExtra <- coef(fit)[["IoptExtra"]]
        # Iopt <- Ek + IoptExtra
        QY_max <- coef(fit)[["QY_max"]]


        output_data <- rbind(output_data, data.frame(
            SampleID = sample,
            # @todo make more generic
            Reef = as.character(areaData[1, "Reef"]),
            Habitat = as.character(areaData[1, "Habitat"]),
            HealthScore = as.character(areaData[1, "HealthScore"]),
            Group = as.character(areaData[1, "Group"]),
            Temperature = areaData[1, "Temperature"],
            Site = as.character(areaData[1, "Site"]),
            Area = area,
            QY_max = QY_max,
            Ek = Ek,
            # Iopt = Iopt,
            qy_ek = Webb_QY_PI(QY_max, Ek, Ek),
            AIC = AIC(fit),
            outliersRemoved = nrow(outliers)
        ))


        plot <- plot +
            # geom_hline(yintercept = QY_max, color = "grey", linetype = "dashed", alpha = 0.6) +
            geom_segment(data = data.frame(QY_max = QY_max, Ek = Ek), mapping = aes(x = Ek, y = 0, xend = Ek, yend = Webb_QY_PI(QY_max, Ek, Ek)), color = "grey", alpha = 0.5) +
            geom_point(data = data.frame(QY_max = QY_max, Ek = Ek), mapping = aes(x = Ek, y = Webb_QY_PI(QY_max, Ek, Ek)), pch = 4, size = 2.5) +
            geom_segment(data = data.frame(QY_max = QY_max, Ek = Ek), mapping = aes(x = 0, y = QY_max, xend = Ek, yend = 0), color = "grey", linetype = "dotted", alpha = 0.4)
        # geom_vline(xintercept = Ek, color = "grey", linetype = "dashed", alpha = 0.6)
        # geom_segment(data = data.frame(QY_max = QY_max, Ek = Ek), mapping = aes(x = Ek, y = QY_max, xend = Ek, yend = 0), color = "grey", linetype = "dashed")

        # Save the curve for plotting later
        pars <- seq(0, 1800, 1) # get pars from 0 to 1800 to plot the curve against
        curve <- data.frame(PAR = pars, QY = Webb_QY_PI(QY_max, Ek, pars), Area = area)
        fit_curves <- rbind(fit_curves, curve)
    }

    fit_curves$Area <- as.factor(fit_curves$Area)


    # plot
    plot <- plot +
        geom_hline(yintercept = 0, color = "grey", alpha = 0.6) +
        # Data
        geom_line(data = sampleData, mapping = aes(x = PAR, y = QY, col = Area), alpha = 0.2) +
        geom_point(data = sampleData, mapping = aes(x = PAR, y = QY, col = Area)) +
        # Fit 1
        # geom_line(data = sampleData, mapping = aes(x = PAR, y = QY_fit, col = Area), linetype = 1) +
        geom_line(data = fit_curves, mapping = aes(x = PAR, y = QY, col = Area), linetype = 1) +

        coord_cartesian(ylim = c(0, 1), xlim = c(0, max(sampleData$PAR))) +
        ggtitle(sample)

    # print(plot)
    suppressMessages(ggsave(paste0(plots, sample, "Webb.png"), plot))
}

cat("\n")

write.csv(output_data, output)
```
