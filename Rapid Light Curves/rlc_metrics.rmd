Processes the RLC part of the Fluorcam data with PI curves to extract Pmax, alpha, ek
input: Rapid Light Curves/fluorcam_RLC_data.csv
output: Rapid Light Curves/RLC_metrics.csv


```{r}
rlc_data <- read.csv("Rapid Light Curves/fluorcam_RLC_data.csv", header = TRUE, colClasses = c(
    "character",
    "factor", "factor", "factor", "factor", "factor", "factor", "factor",
    "numeric", "numeric", "numeric", "numeric"
))
```

```{r}
# httpgd outputs plots to browser
library(httpgd)
hgd()

library(ggplot2)
source("christineTheme.r")
```

```{R}
library(minpack.lm) # for nlsLM
library(broom) # for augment
source("nls_outlier_removal.r")

QY_PI <- function(QY_max, Ek, I) {
    return(((QY_max * Ek) * (1 - exp(-I / Ek))) / I)
}


Webb_PI <- function(I, Pmax, alpha) {
    Ek <- Pmax / alpha
    return(
        Pmax * (1 - exp(-I / Ek))
    )
}

Webb_QY_PI <- function(QY_max, Ek, I) {
    Pmax <- QY_max * Ek
    alpha <- Pmax / Ek
    return(Webb_PI(I, Pmax, alpha) / I)
}

Eilers_PI <- function(Pmax, Iopt, a, I) {
    pi <- (Pmax * I) / ((Pmax / (a * Iopt^2)) * I^2 + ((1 - (2 * Pmax) / (a * Iopt)) * I) + (Pmax / a))
    return(pi)
}

Eilers_QY_PI <- function(QY_max, IoptExtra, Ek, I) {
    Iopt <- Ek + IoptExtra
    Pmax <- QY_max * Ek
    alpha <- Pmax / Ek
    return(Eilers_PI(Pmax, Iopt, alpha, I) / I)
}


sampleNames <- c(
    "LI F20",
    "LI F1",
    "LI F2",
    "LI F8",
    "LI S1",
    "LI S3",
    "MO S1",
    "MO S9",
    "RB S1",
    "RB S9",
    "BH 1",
    "BH 6",
    "TB 2"
)
# sampleNames <- levels(as.factor(rlc_data$SampleName)) # all samples

output <- NULL

printOnTop <- function(...values) {
    cat("\33[2K\r", ...values)
}


cat("\n")
for (sample in sampleNames) {
    printOnTop(sample)

    plot <- ggplot() + christineTheme
    fit_curves <- NULL

    sampleData <- filter(rlc_data, SampleName == sample)

    # Ensure no QY is negative
    sampleData$QY <- pmax(sampleData$QY, 0)

    for (well in 1:6) {
        # cat(" well ", well)
        wellData <- filter(sampleData, Well == well)

        simpleMax <- max(wellData$QY)

        # Fit
        ###########

        # First par is never an outlier
        handle_outliers <- function(outliers) filter(outliers, PAR > 100)

        fit_data <- function(data) {
            tryCatch(
                {
                    nlsLM(
                        QY ~ Eilers_QY_PI(QY_max, IoptExtra, Ek, PAR),
                        data = data,
                        start = list(QY_max = simpleMax, IoptExtra = 100, Ek = 500),
                        lower = c(0, 0, 0),
                        upper = c(1, 1700, 1700),
                        control = nls.lm.control(maxiter = 500),
                        # trace=TRUE
                    )
                },
                error = function(e) {
                    cat("error in ", sample, " well ", well, " fit 1\n")
                    stop(e)
                }
            )
        }

        fit <- nls_outlier_removal(
            wellData,
            fit_data = fit_data,
            handle_outliers = handle_outliers
        )

        outliers <- fit$outliers
        fit <- fit$fit

        # plot them to see what's being removed
        if (length(outliers)) {
            plot <- plot +
                geom_point(data = outliers, aes(x = PAR, y = QY), colour = "red", pch = 1, size = 3)
        }

        Ek <- coef(fit)[["Ek"]]
        IoptExtra <- coef(fit)[["IoptExtra"]]
        Iopt <- Ek + IoptExtra
        QY_max <- coef(fit)[["QY_max"]]


        output <- rbind(output, data.frame(
            SampleName = sample,
            Temperature = wellData[1, "Temperature"],
            Reef = as.character(wellData[1, "Reef"]),
            Site = as.character(wellData[1, "Site"]),
            Habitat = as.character(wellData[1, "Habitat"]),
            Pale = as.character(wellData[1, "Pale"]),
            Group = as.character(wellData[1, "Group"]),
            Well = well,
            QY_max = QY_max,
            Ek = Ek,
            Iopt = Iopt,
            qy_ek = Eilers_QY_PI(QY_max, IoptExtra, Ek, Ek),
            AIC = AIC(fit),
            outliersRemoved = nrow(outliers)
        ))


        plot <- plot +
            # geom_hline(yintercept = QY_max, color = "grey", linetype = "dashed", alpha = 0.6) +
            geom_segment(data = data.frame(QY_max = QY_max, Ek = Ek, IoptExtra = IoptExtra), mapping = aes(x = Ek, y = 0, xend = Ek, yend = Eilers_QY_PI(QY_max, IoptExtra, Ek, Ek)), color = "grey", alpha = 0.5) +
            geom_point(data = data.frame(QY_max = QY_max, Ek = Ek, IoptExtra = IoptExtra), mapping = aes(x = Ek, y = Eilers_QY_PI(QY_max, IoptExtra, Ek, Ek)), pch = 4, size = 2.5) +
            geom_segment(data = data.frame(QY_max = QY_max, Ek = Ek), mapping = aes(x = 0, y = QY_max, xend = Ek, yend = 0), color = "grey", linetype = "dotted", alpha = 0.4)
        # geom_vline(xintercept = Ek, color = "grey", linetype = "dashed", alpha = 0.6)
        # geom_segment(data = data.frame(QY_max = QY_max, Ek = Ek), mapping = aes(x = Ek, y = QY_max, xend = Ek, yend = 0), color = "grey", linetype = "dashed")

        # Save the curve for plotting later
        pars <- seq(0, 1800, 1) # get pars from 0 to 1800 to plot the curve against
        curve <- data.frame(PAR = pars, QY = Eilers_QY_PI(QY_max, IoptExtra, Ek, pars), Well = well)
        fit_curves <- rbind(fit_curves, curve)
    }

    fit_curves$Well <- as.factor(fit_curves$Well)


    # plot
    plot <- plot +
        geom_hline(yintercept = 0, color = "grey", alpha = 0.6) +
        # Data
        geom_line(data = sampleData, mapping = aes(x = PAR, y = QY, col = Well), alpha = 0.2) +
        geom_point(data = sampleData, mapping = aes(x = PAR, y = QY, col = Well)) +
        # Fit 1
        # geom_line(data = sampleData, mapping = aes(x = PAR, y = QY_fit, col = Well), linetype = 1) +
        geom_line(data = fit_curves, mapping = aes(x = PAR, y = QY, col = Well), linetype = 1) +

        coord_cartesian(ylim = c(0, 1), xlim = c(0, max(sampleData$PAR))) +
        ggtitle(sample)

    # print(plot)
    suppressMessages(ggsave(paste0("Rapid Light Curves/QY/plots/", sample, "Eilers.png"), plot))
}

cat("\n")

write.csv(output, "Rapid Light Curves/rlc_qy_metrics_eilers.csv")
```

