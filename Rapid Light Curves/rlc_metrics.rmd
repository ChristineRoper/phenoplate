Processes the RLC part of the Fluorcam data with PI curves to extract Pmax, alpha, ek
input: Rapid Light Curves/fluorcam_RLC_data.csv
output: Rapid Light Curves/RLC_metrics.csv


```{r}
rlc_data <- read.csv("Rapid Light Curves/fluorcam_RLC_data.csv", header = TRUE, colClasses = c(
    "character",
    "factor", "factor", "factor", "factor", "factor", "factor", "factor",
    "numeric", "numeric", "numeric", "numeric"
))
```

```{r}
# httpgd outputs plots to browser
library(httpgd)
hgd()

library(ggplot2)
source("christineTheme.r")
```

```{R}
library(minpack.lm) # for nlsLM
library(broom) # for augment
source("Rapid Light Curves/get_qy_ek.r") # for get_qy_ek

QY_PI <- function(QY_max, Ek, I) {
    return(((QY_max * Ek) * (1 - exp(-I / Ek))) / I)
}

sampleNames <- c(
    "LI F20",
    "LI F1",
    "LI F2",
    "LI F8",
    "LI S1",
    "LI S3",
    "MO S1",
    "MO S9",
    "RB S1",
    "RB S9",
    "BH 1",
    "BH 6",
    "TB 2"
)
sampleNames <- levels(as.factor(rlc_data$SampleName)) # all samples

output <- NULL

rlc_data$QY_fit <- NA

progress <- txtProgressBar(
    min = 0,
    max = length(sampleNames),
    style = 3
)

for (sample in sampleNames) {
    # cat(sample, "\n")

    plot <- ggplot() + christineTheme

    sampleData <- filter(rlc_data, SampleName == sample)

    for (well in 1:6) {
        # cat("well ", well, "\n")
        wellData <- filter(sampleData, Well == well)

        simpleMax <- max(wellData$QY)

        # Fit
        ###########

        fit <- tryCatch(
            {
                nlsLM(
                    QY ~ QY_PI(QY_max, Ek, PAR),
                    data = wellData,
                    start = list(QY_max = simpleMax, Ek = 500),
                    # lower = c(0, 0, 0),
                    # upper = c(simpleMax * 1.2, 3, 5000),
                    control = nls.lm.control(maxiter = 500),
                    # trace=TRUE
                )
            },
            error = function(e) {
                cat("error in ", sample, " well ", well, " fit 1\n")
                stop(e)
            }
        )

        QY_max <- coef(fit)[["QY_max"]]
        Ek <- coef(fit)[["Ek"]]

        # Remove outliers
        #################

        # Find outliers using boxplot's internals

        fitted <- augment(fit)
        outliers <- boxplot.stats(fitted$.resid)$out
        outliers <- fitted[fitted$.resid %in% outliers, ]

        # First par is never outlier
        outliers <- filter(outliers, PAR > 100)

        if (length(outliers)) {
            # plot them to see what's being removed
            plot <- plot +
                geom_point(data = outliers, aes(x = PAR, y = QY), colour = "red", pch = 1, size = 3)

            wellData2 <- filter(wellData, !PAR %in% outliers$PAR)
        }

        fit <- tryCatch(
            {
                nlsLM(
                    QY ~ QY_PI(QY_max, Ek, PAR),
                    data = wellData2,
                    start = list(QY_max = simpleMax, Ek = 500),
                    # lower = c(0, 0, 0),
                    # upper = c(simpleMax * 1.2, 3, 5000),
                    control = nls.lm.control(maxiter = 500),
                    # trace=TRUE
                )
            },
            error = function(e) {
                cat("error in ", sample, " well ", well, " fit 2\n")
                print(ggplot(wellData2) +
                    geom_line(aes(x = PAR, y = QY)) +
                    ggtitle("Error fitting this data"))
                stop(e)
            }
        )

        QY_max <- coef(fit)[["QY_max"]]
        Ek <- coef(fit)[["Ek"]]


        output <- rbind(output, data.frame(
            SampleName = sample,
            Temperature = wellData[1, "Temperature"],
            Reef = as.character(wellData[1, "Reef"]),
            Site = as.character(wellData[1, "Site"]),
            Habitat = as.character(wellData[1, "Habitat"]),
            Pale = as.character(wellData[1, "Pale"]),
            Group = as.character(wellData[1, "Group"]),
            Well = well,
            QY_max = QY_max,
            Ek = Ek,
            qy_ek = QY_PI(QY_max, Ek, Ek),
            AIC = AIC(fit),
            outliersRemoved = nrow(outliers)
        ))


        pars <- sampleData[sampleData$Well == well, ]$PAR
        sampleData[sampleData$Well == well, "QY_fit"] <- QY_PI(QY_max, Ek, pars)


        plot <- plot +
            geom_hline(yintercept = QY_max, color = "grey", linetype = "dashed", alpha = 0.1) +
            geom_segment(data = data.frame(QY_max = QY_max, Ek = Ek), mapping = aes(x = 0, y = QY_max, xend = Ek, yend = 0), color = "grey", linetype = "dashed", alpha = 0.1) +
            geom_vline(xintercept = Ek, color = "grey", linetype = "dashed", alpha = 0.1)
        # geom_segment(data = data.frame(QY_max = QY_max, Ek = Ek), mapping = aes(x = Ek, y = QY_max, xend = Ek, yend = 0), color = "grey", linetype = "dashed")
    }


    # plot
    plot <- plot +
        geom_hline(yintercept = 0, color = "grey", linetype = "dashed", alpha = 0.1) +
        # Data
        geom_line(data = sampleData, mapping = aes(x = PAR, y = QY, col = Well), alpha = 0.1) +
        geom_point(data = sampleData, mapping = aes(x = PAR, y = QY, col = Well)) +
        # Fit 1
        geom_line(data = sampleData, mapping = aes(x = PAR, y = QY_fit, col = Well), linetype = 1) +
        coord_cartesian(ylim = c(min(sampleData$QY), max(sampleData$QY))) +
        ggtitle(sample)

    # print(plot)
    suppressMessages(ggsave(paste0("Rapid Light Curves/QY/plots/", sample, ".png"), plot))

    setTxtProgressBar(progress, getTxtProgressBar(progress) + 1)
}
close(progress)

write.csv(output, "Rapid Light Curves/rlc_qy_metrics.csv")
```
